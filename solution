
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <math.h>

struct dot {                                                       //структура точки що складається з х та у координат
	int x;
	int y;
};

int main()
{
	//Як вже повелося не зміг утриматись від створення друкованого логотипу роботи в консолі :з
	printf("__    __  __ __  ____       __   __ __   _____        \n");
	printf("||\\  /||  || //  ||/\\\\      ||\\  || ||  |____ |   \n");
	printf("||\\\\//||  ||//   ||\\//      ||\\\\ || --    __/_/  \n");
	printf("|| \\/ ||  ||\\\\   ||--       || \\\\||      / /___  \n");
	printf("||    ||  || \\\\	 ||	    ||	\\_|     |______| \n");
	printf("\n");                                      //для красивого оформлення 
	for (int i = 0; i < 45; i++) {                     //замість того щоб в коді писати 45 "-" я зробив цикл, щоб виводило потрібну мені кількість "-"
		printf("-");
	}
	printf("\n \n");
	setlocale(LC_ALL, "ukr");                                      //функція для встановлення української мови в консолі
	int n;                                                         //кількість кутів n-кутника (далі вводиться користувачем)
	int booller=0, x1=0, x2=0, y1=0, y2=0;                         //booller- змінна використовується замість буллевого оператора, ікси та ігрики будуть необхідні для виводу найвіддаленіших точок
	float lenght_temp=0, lenght=0;                                 //довжина та тимчасова довжина- будуть використовуватись при знаходженні найбільшої відстані між точками та при виводі їх
	do {                                                           //цикл- буде просити ввести кількість кутів допоки вони не будуть 3 або більше (трикутник- найменший n-кутник)
		printf("Введiть n: ");                                     
		scanf_s("%d", &n);
		printf("\n");
	} while (n < 3);
	printf("\n");                                     
	for (int i = 0; i < 45; i++) {                     
		printf("-");
	}
	printf("\n \n");
	dot* figure;                                                   //оголошення динамічного масиву розмірністю з кількість кутів кожен елемент котрого це точка- структура, що містить координату х та координату у
	figure = (dot*)malloc(n * sizeof(struct dot));
	dot* figure_temp;                                              //оголошення динамічного масиву аналогічного до попереднього але розмірністю 1. Використовуватись він буде при операціях порівняння як буфер.
	figure_temp = (dot*)malloc(1 * sizeof(struct dot)); 
	printf("Введiть координати для %d вершин\n\n", n);             //запит на ввод координат для n-кількості вершин
	do {                                                           //цикл що буде ітеруватись допоки буллева змінна буде набувати значення 1 (далі більший опис) 
		booller = 0;                                               //оновлення буллевої змінної кожне ітерування 
		for (int i = 0; i < n; i++) {                              //цикл для вводу координат
			printf("Введiть координати %d вершини\n", i + 1);
			printf("Введiть x: ");
			scanf_s("%d", &figure[i].x);
			printf("Введiть y: ");
			scanf_s("%d", &figure[i].y);
			printf("\n");
			printf("\n");                                         
			for (int j = 0; j < 45; j++) {                     
				printf("-");
			}
			printf("\n \n");
		}
		//(x3 — x1) * (y2 — y1) — (x2 — x1) * (y3 — y1) = 0;   -- якщо ця умова відбувається- три точки у нас знаходяться на одній прямій
		//3 = l, 1 = i, 2 = j;                                 -- для зручності означив індекси в формулі індексами циклів
		// x(l)-x(i) * y(j)-y(i) - x(j) - x(i) * y(l)-y(i);    -- координати з підставленими індексами циклів
		for (int i = 0; i < n; i++) {                              //цикл для індексації умовних x1 y1
			for (int j = 0; j < n; j++) {                          //цикл для індексації умовних x2 y2
				if (i == j) {                                      //для запобіганню перевірці однієї і тієї самої точки- пропускаємо ітерування, якщо індекси співпадають
					continue;
				}
				for (int l = 0; l < n; l++) {                      //цикл для індексації умовниї x3 y3
					if (j == l or i == l) {                        //аналогічно до попередньої перевірка співпадіння l з i та j 
						continue;
					}
					if (((figure[l].x - figure[i].x) * (figure[j].y - figure[i].y)) - ((figure[j].x - figure[i].x) * (figure[l].y - figure[i].y)) == 0) {  //формула для перевірки розташування трьох точок на одній прямій
						booller = 1;                               //якщо будь які 3 точки лежать на одній прямій- через них утворюється не n-кутник а n-1-кутник, а це не відповідає умовам задачі тому зупиняємо всі цикли за допомогою буллевої змінної
						break; 
					}
				}
				if (booller == 1) {
					break;
				}
			}
			if (booller == 1) {
				printf("Введiть вершини заново!!!\n\n");            //просимо ввести все заново якщо до цього ввели неправильно				
				break;
			}
		}
	} while (booller == 1);
	printf("\n");                                     
	for (int i = 0; i < 45; i++) {                     
	}
	printf("\n \n");
	//ось і закінчився найскладніший у роботі етап- перевірка правильності вводу вершин n-кутника
	for (int i = 0; i < n; i++) {                                   //цикл для індексації x у першої точки
		
		for (int j = 0; j < n; j++) {                               //цикл для індексації x у другої точки
			
			if (j == i) {                                           //для запобіганню вимірюванню відстані точки відносно самої себе пропускаємо ітерацію якщо індекс j == i 
				continue;                      
			}
			//починається ще цікавинка
			figure_temp->x = figure[j].x - figure[i].x;             //надаємо буферному масиву що сам по собі є фактично відображенням вектора значення, тобто від координат кінця цього вектору (точки j) віднімаємо початок(i)
			figure_temp->y = figure[j].y - figure[i].y;             
			lenght_temp = sqrt(pow(figure_temp->x,2)+pow(figure_temp->y,2)); //визначаємо довжину вектора між двома точками за формулою
			if (booller == 0) {                                     //для корректної роботи один раз за всі ітерації надаємо значенні довжини значення тимчасової довжини поза умовою довжина<довжина тимчасова
				lenght = lenght_temp;
				booller = 1;
			}
			if (lenght < lenght_temp) {                             //якщо довжина тимчасова більша ніж довжина надаємо значення х1 х2 у1 у2 для подальшого їх виводу а також надаємо значенні довжини значення тимчасової множини
				x1 = figure[i].x;
				x2 = figure[j].x;
				y1 = figure[i].y;
				y2 = figure[j].y;
				lenght = lenght_temp;
			}
		}
	}
	//нарешті! кінець роботи!!
	printf("Найбiльша вiдстань мiж вершинами (%d;%d) та (%d;%d) == %.2f\n",x1,y1,x2,y2, lenght); //виводимо координати найбільш віддалених точок та їх відстань 
	printf("Дякую за користування програмою!\nАвтор- ваш нескромний студент: Мединський Я.А. студент групи АС-224 :з\n");
}
